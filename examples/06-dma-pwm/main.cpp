#include <bmt.h>

using namespace Bmt;
using namespace Bmt::Timer;

#ifdef STM32F103xB
#	include "hal.f103.h"
#elif defined(STM32L432xx)
#	include "hal.l432.h"
#elif defined(STM32G431xx)
#	include "hal.g431.h"
#else
#error Unsupported configuration
#endif


// ECG sample table
static constexpr uint8_t s_EcgTable[] =
{
	0x2D, 0x2D, 0x2F, 0x30, 0x31, 0x32, 0x34, 0x34,
	0x35, 0x36, 0x36, 0x37, 0x39, 0x3A, 0x3B, 0x3C,
	0x3E, 0x3F, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x43,
	0x43, 0x43, 0x42, 0x40, 0x3F, 0x3F, 0x3E, 0x3C,
	0x3B, 0x3A, 0x38, 0x35, 0x34, 0x33, 0x31, 0x30,
	0x2F, 0x2E, 0x2D, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
	0x2C, 0x2A, 0x29, 0x27, 0x25, 0x25, 0x23, 0x23,
	0x21, 0x21, 0x20, 0x20, 0x24, 0x25, 0x28, 0x2E,
	0x5C, 0x9E, 0xD6, 0xF4, 0xFD, 0xFC, 0xED, 0xD9,
	0xC2, 0xAE, 0x9E, 0x8A, 0x78, 0x64, 0x53, 0x41,
	0x36, 0x2B, 0x20, 0x15, 0x0E, 0x08, 0x0F, 0x14,
	0x19, 0x1B, 0x1E, 0x20, 0x22, 0x23, 0x24, 0x25,
	0x26, 0x26, 0x27, 0x27, 0x28, 0x29, 0x2A, 0x2A,
	0x2A, 0x2B, 0x2B, 0x2C, 0x2C, 0x2D, 0x2E, 0x2D,
	0x2D, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C,
	0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2D, 0x2D, 0x2D,
	0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F, 0x30, 0x30,
	0x31, 0x31, 0x32, 0x32, 0x33, 0x33, 0x34, 0x35,
	0x36, 0x37, 0x39, 0x3A, 0x3A, 0x3B, 0x3C, 0x3E,
	0x3F, 0x3F, 0x40, 0x42, 0x43, 0x44, 0x45, 0x46,
	0x47, 0x47, 0x49, 0x49, 0x4A, 0x4A, 0x4A, 0x4A,
	0x4B, 0x4B, 0x4B, 0x4B, 0x4B, 0x4C, 0x4C, 0x4C,
	0x4D, 0x4D, 0x4D, 0x4D, 0x4C, 0x4C, 0x4B, 0x4B,
	0x4B, 0x4A, 0x49, 0x48, 0x47, 0x47, 0x46, 0x45,
	0x44, 0x44, 0x43, 0x43, 0x42, 0x40, 0x3F, 0x3F,
	0x3E, 0x3C, 0x3B, 0x3A, 0x3A, 0x39, 0x38, 0x37,
	0x36, 0x35, 0x35, 0x34, 0x34, 0x34, 0x34, 0x33,
	0x33, 0x32, 0x32, 0x32, 0x31, 0x31, 0x31, 0x31,
	0x31, 0x31, 0x30, 0x30, 0x30, 0x2F, 0x2E, 0x2E,
	0x2D, 0x2D, 0x2C, 
};

// Size of the table containing ECG samples
constexpr uint32_t kTableSize = _countof(s_EcgTable);
// We want to specify dummy counts on update timer, within updates
// (required to increase timer clock frequency)
constexpr uint32_t kDummyCount = 100;


// Computes the prescaler for 1 MHz counter speed
typedef InternalClock_Hz <kPwmTimer, SysClk, 1000000> PwmFreq;
// PWM should quantize a byte (0-255)
typedef Any<PwmFreq, Mode::kUpCounter, 255> Pwm;

// The output channel
typedef AnyOutputChannel<Pwm
	, kPwmOutChannel
	, OutMode::kPWM1
	, Output::kEnabled
	, Output::kDisabled
	, true
	, true
> PwmOut;

// Heart rate
constexpr uint32_t kBPM = 60;

// Data rate
constexpr uint32_t kSPS = kBPM > 60 
	? 400 + 3*(kBPM - 60)
	: 400
	;
// Computes the prescaler to copy sample table to PWM (x kDummyCount)
typedef InternalClock_Hz <kUpdateTimer, SysClk, kDummyCount * kSPS> UpdateFreq;
// Updates PWM values
typedef Any<UpdateFreq, Mode::kUpCounter, kDummyCount -1> Updater;

// DMA is triggered on every timer 2 update
typedef Dma::AnyChannel<
	IdDmaUpdate
	, Dma::Dir::kMemToPer			// Run samples in a single shot then stop
	, Dma::PtrPolicy::kBytePtrInc	// source buffer are bytes
	, Dma::PtrPolicy::kLongPtr		// destination CCR register
> TheDma;


// A stopwatch to control timing
typedef MicroStopWatch <Pwm, Pwm::ToTicks(Msec(60 * 1000UL / kBPM))> Tick32;


/*
This function is required by STM32 startup file and called during
initial startup.
*/
extern "C" void SystemInit()
{
	__NOP();
	// Reset clock system before starting program
	System::Init();
	// Initialize Port A, B and C
	InitPA::Init();
	InitPB::Init();
	InitPC::Init();
	// Starts desired clock
	SysClk::Init();
	// Init PWM output
	PwmOut::Init();
	// Init sample updater
	Updater::Init();
	// Sample updates using DMA
	TheDma::Init();
	__NOP();
}



int main()
{
	__NOP();
	// Initialize DMA to transfer values to CCR0 of PWM Output
	TheDma::Setup();
	TheDma::Start(s_EcgTable, PwmOut::GetCcrAddress(), _countof(s_EcgTable));
	// Starts the PWM
	Pwm::CounterStart();
	// Starts the PWM updater
	Updater::EnableUpdateDma();
	Updater::CounterStart();
	Tick32 stopwatch;
	while (true)
	{
		__NOP();
		if (!stopwatch.IsNotElapsed())
		{
			LedOn();
			TheDma::Start(s_EcgTable, PwmOut::GetCcrAddress(), _countof(s_EcgTable));
		}
		else if (IsLedOn()
			&& (TheDma::GetTransferCount() < (7 * kTableSize / 8)))
		{
			LedOff();
		}
	}
	return 0;
}

